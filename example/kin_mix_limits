#!/usr/bin/python
import numpy as np
import os
import subprocess
import sys
import time
from collections import OrderedDict
from misc import contourLogPlot, plotBisectResult, floatToString
from multiprocessing import cpu_count
from multiprocessing import Pool
import traceback
import functools

ZPMSYS =  os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
wdir=''

# Set Grid parameters
mdim = 5 # Mass
cdim = 2 # Mixing

widths = [0.0,0.2]#,0.001]#,0.005,0.01,0.05,0.1,0.25,0.5]

# Set weather to use bisection method
# to scan mixing or use fixed grid
gridMode = False
# If in bisection mode and max chi doesn't exclude;
# keep looking for exclusion limit:
keepGoing=False

#Loop over Z' masses and mixings
gx= 0.01  #Influences width (set it small)

"""
Python pool is buggy for passing exceptions except
if the exception class is inheirting directly from 'Exception'
which is not the case for KeyboardInterrupt
"""
class KeyboardInterruptError(Exception): pass
# Decorator for passing exceptions in parallel to output
def trace_unhandled_exceptions(func):
    @functools.wraps(func)
    def wrapped_func(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except KeyboardInterrupt:
            raise KeyboardInterruptError()
        except:
            print 'Exception in '+func.__name__
            traceback.print_exc()
            raise
    return wrapped_func


#Function that writes input file for zprimate
def writeSettingsFile(filepath, outdir, acc, modelfile, proc):
    f=open(filepath, 'w')

    if proc ==1:
        lum = 20.3
        effs = "eff_el.dat"
        lims = "el_lims"
    elif proc ==2:
        lum = 20.5
        effs = "eff_mu.dat"
        lims = "mu_lims"    
        
    params="""$VERBOSE = 1
    $ACC = %(acc)s
    $FORCE = 1
    $ODIR = %(outdir)s
    $MODEL = %(model)s
    $PROC = %(proc)s
    $EBEAM = 8000
    $LUM = %(lum)s
    $BINS =  analyses/arXiv_1405_4123/bins.dat
    $EFFICIENCIES = analyses/arXiv_1405_4123/%(effs)s
    $LIMITS = analyses/arXiv_1405_4123/%(lims)s"""

    dictionary = { 'acc' : acc, 'outdir':outdir, 'model' : modelfile, 'proc':proc, 'lum':lum, 'effs':effs, 'lims':lims}          
    f.write(params % dictionary)
    f.close()

  
  
#Function that writes Z' model file
def writeModel(filepath, mass, mixing, coupling, HWidth = 0):
    f=open(filepath, 'w')    
    
    params="""$GENERAL
mzp = %(mzp)s
gx = %(gx)s
chi = %(chi)s
whid = %(HWidth)s
$END
"""
    dictionary = { 'mzp' : mass, 'gx': coupling, 'chi' : mixing, 'HWidth' : HWidth}
    f.write(params % dictionary)
    f.close()  

"""
Tries to find the limiting R value by employing bisection
All paramters except the width are fixed and should be supplied

Asumes monotonicity in chi. This is not necessarily given for
arbitrarily large chi.
"""
@trace_unhandled_exceptions
def startZpBisection(mass,wHidPercent,outDir,maxIteration=5,accGoal=1e-3):
    if not os.path.exists(outDir):
        os.makedirs(outDir)
    # First calculate Robs for crude grid
    # Use the grid since it produces log-const spacing to quickly scan region
    cdim=4
    lowGrid=-2.3
    upperGrid=1.0
    mixings = np.logspace(lowGrid,upperGrid,cdim)
    Rdict=dict()
    iteration=0
    Robs=-1
    arrR=[-1,-1]
    arrChi=[-1,-1]
    grid=True
  
    while(iteration<maxIteration and abs(1.0-Robs)>accGoal):
        for ichi, chi in enumerate(mixings):
            flip=False
            Robs = startZPriMATE(mass,chi,wHidPercent,gx,outDir)
            iteration+=1
            
            arrR=[Robs,arrR[0]]
            Rdict[chi]=Robs
            # Check if we passed R=1.0 and update boundaries accordingly
            if (1-arrR[0])*(1-arrR[1]) < 0.0:
                flip=True
                arrChi=[chi,arrChi[0]]
                break
            elif not grid:
                arrChi=[chi,arrChi[1]]
                break
            else:
                arrChi=[chi,arrChi[0]]
        else:
            if not keepGoing:
                break
            # If turning point wasn't reached we probably stepped
            # into a mass region where we need very strong couplings
            # to exclude. This is probably not necessary
        
            print "Extending grid..."
            lowGrid=upperGrid
            upperGrid=lowGrid+1.0
            mixings = np.logspace(lowGrid,upperGrid,cdim)
            continue

        if abs(arrChi[0]/arrChi[1]-1.0)<accGoal:
            break
        chi=(arrChi[0]+arrChi[1])/2.0

        # If new value is at most accGoal away from the old one terminate
        mixings=[chi]
        grid=False
    return OrderedDict(sorted(Rdict.items(), key=lambda t: t[0])), mass

def startZPriMATE(mass,chi,wHidPercent,gx,wdir):
    #Zprimate executable and package directory  
    ZPMX = "./zprimate"

    os.chdir(ZPMSYS)
    #Directory for zprimate output  
    zdir = os.path.join(wdir,"ZPM")

    if not os.path.isdir(zdir):
        os.makedirs(zdir)
    #Directory to store startup files  
    indir = os.path.join(wdir, "input")
    if not os.path.isdir(indir):
        os.makedirs(indir)
    modelfile = os.path.join(indir,"model")
    settingsFile = os.path.join(indir, "settings")

    #Write settings
    whid=mass*wHidPercent
    writeModel(modelfile, mass, chi, gx, whid)
    writeSettingsFile(settingsFile, zdir, 1e-2, modelfile, procID)
    zpm = subprocess.Popen(["%s %s" %(ZPMX, settingsFile) ], stdout=subprocess.PIPE, shell=True)

    (out, err) = zpm.communicate() #Catch output and error if sent to PIPE

    #Get exclusion limits for current model
    robs = -1
    f= open(zdir + "/results", 'r')
    lno = 0
    for line in f:
        tab = line.split('|')
        if lno== 7:
            robs = np.double(tab[1])
        lno += 1
    print robs
    return robs


    
    
def main(procID,resultDir="KINETIC_MIXING"):
    global wdir
    #Time the total execution
    start = time.time()

    #Create Result directoy in user's home 
 
    if procID==1:
        wdir=resultDir+"_EE"
    elif procID==2:
        wdir=resultDir+"_MM"
    else:
        sys.exit("\nERROR: INVALID INPUT!\nProcess key on input:\n\t1 = ee\n\t2 = mu mu\n")

    wdir = os.path.join(os.path.expanduser("~"),wdir)
    if not os.path.isdir(wdir):
        os.makedirs(wdir)


    masses = np.logspace(2, 3.544, mdim)  
    mixings = np.logspace(-2.3, 0, cdim)
    results=dict()
    for iw, whid in enumerate(widths):
        print "Width",whid
        limfile = os.path.join(wdir,"limits"+floatToString(whid*100)+".dat")
    
        pool = Pool(cpu_count())
        processes=[]
        if gridMode:
            lobs =  np.zeros((cdim, mdim))
            limits = open(limfile, 'w')
            line0 = "%-20s"%"Chi\M[GeV]"
            for m in masses:
                line0 += "%-10.1f"%m
            limits.write(line0+"\n")
            limits.close()
            for ic, mix in enumerate(mixings):
                string = "%-20.4g"%mix
                for im, mzp in enumerate(masses):
                    robs=startZPriMATE(mzp,mix,whid,gx,wdir)
                    #Append results to lists and file
                    lobs[ic, im] = robs
                    results[whid]=lobs
                    string += "%-10.2g"%robs
            limits = open(limfile, 'a')
            limits.write(string+"\n")
            limits.close()
        else:
            lobs=OrderedDict()
            with open(limfile,'w') as limFile:
                limFile.write("# Limits generated using bisection method\n")
            for iMass, mass in enumerate(masses):
                p=pool.apply_async(
                    startZpBisection,
                    args=(mass,
                          whid,
                          os.path.join(wdir,"output/tmp"+str(iMass))
                      )
                )
                processes.append(p)
            try:
                for p in processes:
                    p.wait()
                    assert p.successful()
                    rValues, mass = p.get(1e2)
                    lobs[mass]=rValues
                    with open( limfile,'a') as limFile:
                        limFile.write("$MASS %-10.1f\n"%mass)
                        for key in rValues:
                            line = "%-20.4g\t%-10.4g\n"%(key,rValues[key])
                            limFile.write(line)
                        limFile.write("\n\n")
            except:
                pool.terminate()
                pool.join()
                raise
            pool.close()
            pool.join()
            # Plotting handled by external function to enable re-plotting
        if gridMode:
            contourLogPlot(
                    lobs,
                    masses,
                    mixings,
                    os.path.join(wdir,"limits"+floatToString(whid*100)+".pdf"),
                    ZPMSYS
                )
        else:
            plotBisectResult(
                lobs,
                whid,
                os.path.join(wdir,"limits"+floatToString(whid*100)+".pdf"),
                    ZPMSYS
                )
    plotBisectResult(
        os.path.join(wdir,"limits"),
        widths,
        os.path.join(wdir,"limitTot.pdf")
        )
    #Write parameters file 
    parfile = open(wdir+"/parameters.txt", 'w')
    parfile.write("Parameters of limit calculation\n%s\n\n"%('-'*25))
    if procID==1:
        channel="e+e-"
    else:
        channel="mu+mu-"
    parfile.write("%-20s | %-5s\n"%("Channel", channel))  
    parfile.write("%-20s | %-5s\n"%("Grid (mass x mix)", "%s x %s"%(mdim, cdim)))
    parfile.close()

    #Print execution time
    end = time.time()
    diff =   (end- start)
    seconds = diff%60
    minutes = float(diff - seconds)/60
    print "FINISHED!\nExecution took %i m %.1f sec\n"%(int(minutes), seconds)  

if __name__=="__main__":
    argc=len(sys.argv)
    if argc!=2:
        sys.exit("\nERROR: WRONG NUMBER OF ARGUMENTS!\nOne argument expected - process key:\n\t1 = ee\n\t2 = mu mu\n")
    procID = int(sys.argv[1])

    main(procID)
