#!/usr/bin/python
import numpy as np
import os
import subprocess
import sys
import time
from collections import OrderedDict
from misc import contourLogPlot, plotBisectResult, floatToString, progressBar, plotBisectContour
from multiprocessing import cpu_count
from multiprocessing import Pool
import traceback
import functools


ZPMSYS =  os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
wdir=''

# Set Grid parameters
mdim = 50 # Mass
cdim = 40 # Mixing

widths = [0.0,0.001,0.005,0.01,0.05,0.1,0.25,0.5,1.0]

# Set weather to use bisection method
# to scan mixing or use fixed grid
gridMode = False
# If in bisection mode and max chi doesn't exclude;
# keep looking for exclusion limit:
keepGoing=False

#Loop over Z' masses and mixings
gx= 0.01  #Influences width (set it small)

"""
Python pool is buggy for passing exceptions except
if the exception class is inheirting directly from 'Exception'
which is not the case for KeyboardInterrupt
"""
class KeyboardInterruptError(Exception): pass
# Decorator for passing exceptions in parallel to output
def trace_unhandled_exceptions(func):
    @functools.wraps(func)
    def wrapped_func(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except KeyboardInterrupt:
            raise KeyboardInterruptError()
        except:
            print 'Exception in '+func.__name__
            traceback.print_exc()
            raise
    return wrapped_func


#Function that writes settings file for zprimate
def writeSettingsFile(filepath, outdir, acc, modelfile, proc):
    f=open(filepath, 'w')

    if proc ==1:
        lum = 20.3
        effs = "eff_el.dat"
        lims = "el_lims"
    elif proc ==2:
        lum = 20.5
        effs = "eff_mu.dat"
        lims = "mu_lims"    
     
            
    params="""$VERBOSE = 1
    $ACC = %(acc)s
    $FORCE = 1
    $ODIR = %(outdir)s
    $MODEL = %(model)s
    $PROC = %(proc)s
    $EBEAM = 8000
    $LUM = %(lum)s
    $BINS =  analyses/arXiv_1405_4123/bins.dat
    $EFFICIENCIES = analyses/arXiv_1405_4123/%(effs)s
    $LIMITS = analyses/arXiv_1405_4123/%(lims)s"""

    dictionary = { 'acc' : acc, 'outdir':outdir, 'model' : modelfile, 'proc':proc, 'lum':lum, 'effs':effs, 'lims':lims}          
    f.write(params % dictionary)
    f.close()

  
  
#Function that writes Z' model file
def writeModel(filepath, mass, mixing, coupling, HWidth = 0):
    f=open(filepath, 'w')    
    
    params="""$GENERAL
mzp = %(mzp)s
gx = %(gx)s
chi = %(chi)s
whid = %(HWidth)s
$END
"""
    dictionary = { 'mzp' : mass, 'gx': coupling, 'chi' : mixing, 'HWidth' : HWidth}
    f.write(params % dictionary)
    f.close()  

"""
Tries to find the limiting R value by employing bisection
All paramters except the width are fixed and should be supplied

Asumes monotonicity in chi. This is not necessarily given for
the whole parameter space
"""
@trace_unhandled_exceptions
def startZpBisection(mass,wHidPercent,outDir,maxIteration=25,accGoal=1e-3,gridStart=5e-3,gridEnd=10.0):
    if not os.path.exists(outDir):
        os.makedirs(outDir)
    # First calculate Robs for crude grid
    # Use the grid since it produces log-const spacing to quickly scan region
    cdim=5
    lowGrid=np.log10(gridStart)
    upperGrid=np.log10(gridEnd)
    mixings = np.logspace(lowGrid,upperGrid,cdim)
    Rdict=dict()
    iteration=0
    Robs=-1
    arrR=[-1,-1]
    arrChi=[-1,-1]
    grid=True
  
    while(iteration<maxIteration and abs(1.0-Robs)>accGoal):
        for ichi, chi in enumerate(mixings):
            flip=False
            Robs = startZPriMATE(mass,chi,wHidPercent,gx,outDir)
            iteration+=1
            
            arrR=[Robs,arrR[0]]
            Rdict[chi]=Robs
            # Check if we passed R=1.0 and update boundaries accordingly
            if (1-arrR[0])*(1-arrR[1]) < 0.0:
                flip=True
                arrChi=[chi,arrChi[0]]
                break
            elif not grid:
                arrChi=[chi,arrChi[1]]
                break
            else:
                arrChi=[chi,arrChi[0]]
        else:
            if not keepGoing:
                break
            # If turning point wasn't reached we probably stepped
            # into a mass region where we need very strong couplings
            # to exclude. This is probably not necessary
            
            #print "Extending grid..."
            lowGrid=upperGrid
            upperGrid=lowGrid+1.0
            mixings = np.logspace(lowGrid,upperGrid,cdim)
            continue

        # If new value is at most accGoal away from the old one terminate
        if abs(arrChi[0]/arrChi[1]-1.0)<accGoal:
            break
        chi=(arrChi[0]+arrChi[1])/2.0

        mixings=[chi]
        grid=False
    return OrderedDict(sorted(Rdict.items(), key=lambda t: t[0])), mass

@trace_unhandled_exceptions
def startZPriMATE(mass,chi,wHidPercent,gx,wdir):
    #Zprimate executable and package directory  
    ZPMX = "./zprimate"

    os.chdir(ZPMSYS)
    #Directory for zprimate output  
    zdir = os.path.join(wdir,"ZPM")

    if not os.path.isdir(zdir):
        os.makedirs(zdir)
    #Directory to store startup files  
    indir = os.path.join(wdir, "input")
    if not os.path.isdir(indir):
        os.makedirs(indir)
    modelfile = os.path.join(indir,"model")
    settingsFile = os.path.join(indir, "settings")

    #Write settings
    whid=mass*wHidPercent
    writeModel(modelfile, mass, chi, gx, whid)
    writeSettingsFile(settingsFile, zdir, 1e-2, modelfile, procID)
    zpm = subprocess.Popen(["%s %s" %(ZPMX, settingsFile) ], stdout=subprocess.PIPE, shell=True)

    (out, err) = zpm.communicate() #Catch output and error if sent to PIPE

    #Get exclusion limits for current model
    robs = -1
    resultFile = os.path.join(zdir,"results")
    # Wait a second for file to be written

    with open(resultFile, 'r') as f:
        lno = 0
        for line in f:
            tab = line.split('|')
            if lno== 7:
                robs = np.double(tab[1])
            lno += 1
    return robs


def main(procID,resultDir="KINETIC_MIXING"):
    global wdir
    #Time the total execution
    start = time.time()

    #Create Result directoy in user's home 
 
    if procID==1:
        wdir=resultDir+"_EE"
    elif procID==2:
        wdir=resultDir+"_MM"
    else:
        sys.exit("\nERROR: INVALID INPUT!\nProcess key on input:\n\t1 = ee\n\t2 = mu mu\n")

    wdir = os.path.join(os.path.expanduser("~"),wdir)
    if not os.path.isdir(wdir):
        os.makedirs(wdir)

    upperMGrid=3500.0
    lowerMGrid=100.0
    masses = np.logspace(np.log10(lowerMGrid),np.log10(upperMGrid), mdim)  
    mixings = np.logspace(-2.3, 0, cdim)
    results=dict()
    for iw, whid in enumerate(widths):
        print "Width",whid
        limfile = os.path.join(wdir,"limits"+floatToString(whid*100)+".dat")
    
        pool = Pool(cpu_count())
        processes=[]
        if gridMode:
            lobs =  np.zeros((cdim, mdim))
            with open(limfile, 'w') as limits:
                line0 = "%-20s"%"Chi\M[GeV]"
                for m in masses:
                    line0 += "%-10.1f"%m
                limits.write(line0+"\n")
            for ic, mix in enumerate(mixings):
                string = "%-20.4g"%mix
                for im, mzp in enumerate(masses):
                    robs=startZPriMATE(mzp,mix,whid,gx,wdir)
                    #Append results to lists and file
                    lobs[ic, im] = robs
                    results[whid]=lobs
                    string += "%-10.2g"%robs
            with open(limfile, 'a') as limits:
                limits.write(string+"\n")
        else:
            lobs=OrderedDict()
            with open(limfile,'w') as limFile:
                limFile.write("# Limits generated using bisection method\n")
                limFile.write("# Chi\tRobs\n\n")
            for iMass, mass in enumerate(masses):
                p=pool.apply_async(
                    startZpBisection,
                    args=(mass,
                          whid,
                          os.path.join(wdir,"output/tmp"+str(iMass))
                      )
                )
                processes.append(p)
            try:
                prog=0
                procNum=len(processes)
                progressBar(0.0,status="%d/%d"%(prog,procNum))
                for p in processes:
                    p.wait()
                    prog+=1
                    progressBar(float(prog)/float(procNum),status="%d/%d"%(prog,procNum))
                    if p.successful():
                        rValues, mass = p.get()
                        lobs[mass]=rValues
                        with open(limfile,'a') as limFile:
                            limFile.write("$MASS %-10.1f\n"%mass)
                            for key in rValues:
                                line = "%-20.4g\t%-10.4g\n"%(key,rValues[key])
                                limFile.write(line)
                            limFile.write("\n\n")
                    else:
                        limFile.write("Â§Mass run for %s unsuccessful"%str(masses[prog-1]))        
            except:
                print "Terminating pool."
                pool.terminate()
                pool.join()
                raise
            pool.close()
            # wait for processes to be properlly terminated/closed
            pool.join() 
            # Plotting handled by external function to enable re-plotting
        if gridMode:
            contourLogPlot(
                lobs,
                masses,
                mixings,
                os.path.join(wdir,"limits"+floatToString(whid*100)+".pdf"),
                ZPMSYS
            )
        else:
            plotBisectResult(
                lobs,
                whid,
                os.path.join(wdir,"limits"+floatToString(whid*100)+".pdf"),
                ZPMSYS
                )
    if not gridMode:
        plotBisectResult(
            os.path.join(wdir,"limits"),
            widths,
            os.path.join(wdir,"limitTot.pdf")
        )
        plotBisectContour(wdir,'bisectContour.pdf')
    #Write parameters file 
    parfile = open(wdir+"/parameters.txt", 'w')
    parfile.write("Parameters of limit calculation\n%s\n\n"%('-'*25))
    if procID==1:
        channel="e+e-"
    else:
        channel="mu+mu-"
    parfile.write("%-20s | %-5s\n"%("Channel", channel))
    if gridMode:
        parfile.write("%-20s | %-5s\n"%("Grid (mass x mix)", "%s x %s"%(mdim, cdim)))
    else:
        parfile.write("%-20s | %-5s \n"%("Bisection grid (mass)", "%s"%(mdim)))
    parfile.close()

    #Print execution time
    end = time.time()
    diff =   (end- start)
    seconds = diff%60
    minutes = float(diff - seconds)/60
    print "FINISHED!\nExecution took %i m %.1f sec\n"%(int(minutes), seconds)  

if __name__=="__main__":
    argc=len(sys.argv)
    if argc!=2:
        sys.exit("\nERROR: WRONG NUMBER OF ARGUMENTS!\nOne argument expected - process key:\n\t1 = ee\n\t2 = mu mu\n")
    procID = int(sys.argv[1])

    main(procID)
